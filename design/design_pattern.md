接口隔离原则:
    接口的纯洁性:
        1. 接口粒度要尽可能的小，可拓展
        2. 接口粒度不能小于单一职责 (only one thine can change status)
        3. 高内聚 
迪米特法则
    最少知识原则
    1. 朋友类：
        通过参数、成员变量出现在类中， 叫做朋友类
    2. talking to u immediate friend 只和最亲密的朋友交流
    3. know less about u friend and keep distance 不应该通过朋友类的返回值当做执行朋友下一个动作的条件
    
开闭原则
    对修改关闭对拓展开放
    1. 如果原有的实现方式不需要改变， 但是规则变化了 需要对最后的输出结果根据规则进行改变。继承原有的类 根据原有的类的结果进行包装后再输出
        如果以测试驱动开发，修改了原有的实现 需要修改原来的单元测试。
    2. 抽象约束
        + 依赖朋友类的interface 而不是具体的类，interface 中还可以由实类去实现 interface 中的约束
        + 元数据 metadata 控制模块行为
    3. 配置优先
    4. 协议先行
    5. 封装变化

1. option 模式 (皮裤套棉裤) 可以参考[refer GRPC](https://github.com/grpc/grpc-go)
   Go 是支持头等函数的语言 也就是 func 能够成为一个变量
   用func(*V) 模式自定义可改变的 func
   New("init", func changeModel(*V)) struct V

2. 贫血/充血模型:
    贫血:只包含数据，不包含业务逻辑 的数据结构
    充血: both 传统代表DDD 但是DDD是要建立在对业务的 熟悉程度上的， 没有架空的DDD
    
3. 对通用需求的设计与分析
    eg: 监控
        1. 服务的健康监控
        2. 业务的健康监控(支付成功率)
            最小原型的法则 && 测试驱动
4. 四大原则:
    封装: 对外界屏蔽内部的细节，保护成员
    抽象: 如果不能很好的封装那么一定是抽象的不够,需要往上继续抽象
    继承: 倾向于使用组合的形式，继承会有太多的依赖关系
    多态: 程序的拓展性和复用性，至少整体的代码&&逻辑结构是不会变的
    
5. (准则)在面向对象的原则下如何避免面向过程编程:
    1. 去除无用的 get/set (会破坏封装性)
    2. 全局变量 && 全局方法 

6. (准则)面向接口编程
    1. 如果某一种功能 只有一种实现 就没有必要使用面向接口编程
    前提是 已经充分的抽象完， 但是又不能过度的抽象
    
7. 解决性能问题的板斧
    1. eventbus